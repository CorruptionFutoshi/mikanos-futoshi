メモ
1章
・ターミナル起動できないやつ
https://qiita.com/towamz/items/2052f08e9e1af4068a56
・sudoできないやつ
https://qiita.com/kohei-takao/items/3beb89fb95d9cc472125
・Virutual BoxのUbuntuがUSB認識しないやつ
https://lab4ict.com/system/archives/5683
・USBのデバイス名の探し方
→ファイルからボリュームに飛んで、ターミナルで開くボタン押したら現在の場所が出てくる。それとlsblkを照合したらわかる
・.efiはpe形式なのか？→pe形式。exeファイルと同じPE/COFF形式。

2章
・C言語では変数を宣言した場合、その変数にはその変数が格納されるメモリアドレスが入る。
たとえば
int x = 10;
print(x)→10
としたら、xにはメモリアドレスと10が代入される。プログラム上では普通にアクセスすると10の値だけがとれる。&xとするとメモリアドレスがとれる。
print(&x)→0x d800

ポインタ変数はメモリアドレスを格納する変数であり、宣言の際に変数名の前に*をつける。*をつけない変数にメモリアドレスが格納され、*をつけたものには値が入る。
int *px = &x;
print(px)→0xd800
print(\*px)→10
・ポインタのポインタについて、下記のプログラムを想定する。

void f(int** p) {
    *p = (int*)malloc(sizeof(int));
    if (*p != NULL) {
        **p = 42;  // 割り当てたメモリに値を設定
    }
}

int g() {
    int* x = NULL;
    f(&x);
    return 0;
}

肝は
・すべての変数には値と、メモリアドレスが格納されているということ。
・ int\* x = NULL; で宣言される変数xは、int型の変数に対するメモリアドレス（NULL）を格納する変数であるということ。
・x自体の値がNULLであり、メモリアドレスは別にあるということ。

上記のプログラムの挙動
f関数呼び出し時点で、
xの値が示すint型の変数の値→未定義
xの値が示すint型の変数のメモリアドレス→ＮＵＬＬ
xの値→ＮＵＬＬ
xのメモリアドレス→仮に 0x d800とする
&x→xのメモリアドレスであり、0x d800

p→&xであり、0x d800
p\*→&x（メモリアドレス）が示す場所の値 = xの値であり、ＮＵＬＬ
p\*\*→&x（メモリアドレス）が示す場所の値 = xの値（メモリアドレス）が示す場所の値であり、未定義

その後、f関数内にて、
p\*（xの値）に動的にメモリアドレスが割り当てられる。仮に 0x 1040とする
p\*\*（xの値が示す場所（0x 1040）の値）に42が割り当てられる
となり、

f関数呼び出し後には、
xの値が示すint型の変数の値→42
xの値が示すint型の変数のメモリアドレス→0x 1040
xの値→0x 1040
xのメモリアドレス→0xd800
&x→xのメモリアドレスであり、0xd800
となる
・宣言時に型名につける*はその変数が、メモリアドレスを格納する変数であるということを表す。
・参照時に変数につける*は、変数の値（メモリアドレス）が示す先の値を表す。
・ポインタのポインタは、最終的に示された場所の値のみならず、そのメモリアドレスも編集できるのが強みだね
・ポインタについて
https://qiita.com/Yuzu2yan/items/229df1a2a5f044e9c424

3章
・文字列は
CHAR8* header = "Index, Type, PhysicalStart, Attribute\n";
などのようにメモリアドレスを格納する型である*の型に代入できる。代入した場合、文字列の先頭のメモリアドレスがheader変数に格納される。
・USB読み込まない問題→Virtual Boxの設定のUSBのやつ除去してプラスしなおすといける
・C言語では配列名は配列の先頭要素へのポインタとしても機能する
よって、下記のようにしてfile_info_bufferに書き込みができる

UINTN file_info_size + sizeof(EFI_FILE_INFO) + sizeof (CHAR16) * 12;
UINT8 file_info_buffer[file_info_size];
kernel_file ->GetInfo(
kernel_file, &gEfiFileInfoGuid,&file_info_size,file_info_buffer);
・スタックはプログラムの開始時などに確保されるメインメモリ上の領域のこと。
X86_64アーキテクチャではデータを上からうめていくので、アセンブリでのpush操作はRSPに記載されているメモリアドレスの値を8下げる動作を伴う（汎用レジスタのサイズが8バイトなので）
pushし続けた結果、RSPの値が当初確保した領域を超えた場合、スタックオーバーフローとなる
popするたびにデータが解放されて、RSPに記載されているメモリアドレスの値が8上がる

push操作とは、まずRSPの値を8下げて、下げたあとのRSPの値であるメモリアドレスが示す場所に指定したデータを書き込む
pop操作とは、RSPの値であるメモリアドレスが示す場所からデータを読み取り指定したレジスタに書き込む、そのデータはもう不要なのでRSPの値を8上げる（明示的にそこにあったデータを削除するわけではないが、次にpushされた際に上書きされるようにする）

RSPは常にスタックの先頭を指す（pushだけでなく、mov dword ptr [rdb - 4] , 42とかが行われた場合にもぬるっと先頭になってる）
RBPは関数のベースポインタ（関数の実行を行うメモリアドレス）を格納しておくレジスタ

これらを総合して、定番の
push　rbp
mov　rbp , rsp
は

①pushでRSPの値を8下げる（下げる前のRSPと下げた後のRSPの値の示すメモリアドレス間に8バイトのメモリ領域が作られる）
②現在のRSPの値が示すメモリアドレスを先頭にしてRBPの値を書き込む
③RBPに現在のRSPを代入する


仮に、処理が始まる前のRSPを0x7FFFFFFFE000、RBPを0x7FFFFFFFEA00とおくと、各処理でのそれぞれの値は下記のようになる
①RSP→0x7FFFFFFFE000から8下がって、0x7FFFFFFFDFF8
　RBP→0x7FFFFFFFEA00
　メインメモリのアドレス0x7FFFFFFFDFF8→値なし
　メインメモリのアドレス0x7FFFFFFFEA00→この関数を呼び出した関数を呼び出した関数のベースポインタ
②RSP→0x7FFFFFFFDFF8
　RBP→0x7FFFFFFFEA00
　メインメモリのアドレス0x7FFFFFFFDFF8→0x7FFFFFFFEA00（サイズは0x7FFFFFFFDFF8から0x7FFFFFFFE000まで）
③RSP→0x7FFFFFFFDFF8
　RBP→0x7FFFFFFFDFF8
　メインメモリのアドレス0x7FFFFFFFDFF8→0x7FFFFFFFEA00（サイズは0x7FFFFFFFDFF8から0x7FFFFFFFE000まで）

最後に
mov　rsp, rbp
pop　rbp
で終わるのが定番
これをやるとrbpに元からあったrbpの値が書き込まれ、rspは元の値に戻る。今回つかったrbpより下の値は次に別の関数が実行されるときに上書きされていくことになる
・PCを再起動した後は環境変数の設定が必要
→source $HOME /osbook/devenv/buildenv.sh
・動かない原因について
https://zenn.dev/rain_squallman/articles/2d7728f4b5013f
・レジスタはCPUの内部にあり、メインメモリはCPUの外側にある

4章
・makefileのLDFLAGSのメモリアドレスを110000に変える（100000は使用済みらしい）
・各プログラムヘッダエントリ (phdr[i]) は、1つのセグメントに関する情報を保持している
・エラー発生"Could not exit boot service: Invalid Parameter"→ ブートサービス止めた後でPrint文実行しようとしてフリーズしてた
・とりあえずUINT８で領域を確保する理由　バイト単位で管理されてることが多いから、とかなんかな
file_info_sizeがたとえば24（バイト）など、バイト単位での値だったとしたら、
UINT8 file_info_buffer[file_info_size];
とすることで、適切な量のメモリ領域を確保できる。
UINT8 file_info_buffer[24];
としたときに、file_info_bufferに格納されるのは、24バイトの連続したメモリ領域の先頭を指すアドレス。

それに対し、
UINT64 file_info_buffer[file_info_size];
であった場合、かりにこのまま実行したら、
UINT64 file_info_buffer[24];
となり、file_info_bufferに格納されるのは、8 * 24バイトの連続したメモリ領域の先頭を指すアドレスであり、だいぶ不要なメモリをくってしまう。
だからUINT64でやる場合は、
UINT64 file_info_buffer[file_info_size / 8];とする必要があってめんどくさい
・実際、UINT８で宣言するうまみってインデクサ使うときに1増えると1バイト分増えるのがありがてえ　以外にはないか
・MikanLoaderPkgフォルダのMain.cからkernelフォルダのframe_buffer_config.hppをincludeする方法
シンボリックリンクを作る
ln -s ../kernel/frame_buffer_config.hpp frame_buffer_config.hpp


5章
・ビット演算子
<< a　左シフト。a桁だけ左にずらす
&　AND。両方1のときだけ1
・C++のポインタと参照型の違い
参照型は初期化時以外で参照先（アドレス）を変えることができない。つまりconstポインタ型のようなもの。参照先の値自体は変えられる（値型ではなく参照型を引数に設定する理由→引数の変更がしたい場合、それから値ではなく参照をコピーしたほうが軽いので値自体がでかい場合は中身変える予定なくても参照型で受け取ることがある）
使い分ける理由は参照型は指し示す先の値をヌルにできないので、引数とかでは先にヌルがあってほしくない場合は参照型にする
定義はint a =1 があったとして、
ポインタはint *x = &a、参照型はint& x = a
・const int& x　のようなconstで定義した参照型は、参照先（アドレス）はもちろん、参照先の値についても変更できない。
・配列は参照型では表せないらしい。先頭要素のポインタじゃないとだめっぽい
・QEMUでUSBを取り出す時はunmountじゃなくてejectにすると、次回挿入した時に読み取ってくれがち

6章
・なぜScanAllBusでfunction番号をバス番号と対応させているのかがわからない
→ホストブリッジの各ファンクションが各バスに対応しているから
・疑問点
・hankaku.textがどんなかたちでoファイルになってるのかとどうやってoファイルにしたか　あと_binaryシリーズになんで&をつけるのか
・makefileにてなぜ引数なし実行をしたときに、必須項目とターゲットの連環のなかにない.%.d: %.cppのルールが実行されているのか
・AddDeviceとかdevice_numとかあるけど、これFunctionじゃない？DeviceだったらBus番号とDevice番号だけで一意に定まるからFunction番号で回してAddするのは明らかにおかしい。デバイス重複するよなこれ
・下位４ビットをマスクした値→下位４ビットを無視（０に）したもの
・& 0xffuには下位８ビットを抽出する効果がある　あと符号なしにする効果も
・語頭の0xに加えて、末尾にhをつけるという16進法の表し方がある
・メモリアドレスの単位はバイト（0x01と0x02の間には8ビットある）
・わからなくなるやつ
変数に
*をつけるとその変数が指し示す場所に格納されている値がとれる（変数がアドレスじゃないと壊れる）
&をつけるとその変数のアドレスがとれる 
```
int \*ptr;
int data = 5;
ptr = &data;
printf("%d\n", \*ptr); // 出力: 5
printf("%p\n", &data); // 出力: dataのメモリアドレス
```
・宣言時には
*をつけるとポインタの変数になる
&をつけると参照型の変数になる（これはC++特有でCにはない表現）
・代入時には
ポインタ変数にはポインタを
参照型には値を（勝手に参照型にしてくれる）
・アドレスの末尾について
　・b→2進数
　・d→10進数
　・h→16進数
　・u→符号なし
・コンピュータのメインメモリ管理において、有効なメモリアドレスの範囲、および、そのようなアドレスによって識別されるメモリ領域の総体のことをメモリアドレス空間と呼ぶ。すなわち、物理的な空間ではなく、概念
・テンプレートの完全特殊化
→あるテンプレートについて、特定の型が指定された場合にのみ動作する記述ができる。
・テンプレートクラスの場合、メンバ関数（コンストラクタを含む）の定義を通常、クラス定義の外に書く。
・原因は全く不明だがlogger.hppとrun_image.shがmake通らず。エラーはテンプレートがどうとか言ってるけど正しいコードと全く違いはない。相当時間をかけて色々調査した後、諦めて差し替えた。

7章
・pci.cppとpci.hppでエラー発生
→なぜかunknown class name "exception"みたいなエラーが出てmakeが通らない。循環参照っぽいけど全然そんな感じないし意味不明。相当時間をかけて色々調査した後、諦めて差し替えた。
・Message Addressレジスタ及びMessage Dataレジスタの設定を行ってMSIが有効化されると、Message DataレジスタのVectorフィールドに設定された割り込み記述子の番号（IDT内の記述子番号）に紐づけられた割り込み処理が常に呼び出される。マウスの動作もキーボードの動作でも同じ割り込み処理が常に呼び出されるのでその割り込み処理内で適切にハンドリングする必要がある

8章
・alignas (16) uint8_t kernel_main_stack[1024 * 1024];
について、なぜここで新たに作成した領域をスタック領域として使用することで利用可能な三つのタイプでなくなることを期待できるのかわからない。引数として渡されたメモリマップはこのスタック領域が作成される以前のものであり、作成される以前は利用可能な領域なのでは。それともこのようにして確保した領域はこの三つのタイプではないか、あるいはメモリマップ上で歯抜けの部分になるのか。
→このスタック用領域を確保する処理はカーネルに記述されているものの、静的領域であり、ブートローダーによるロード処理時にメモリ上に領域として既に確保される。その上で、メモリマップの取得が行われるので、ブートローダーから引数として渡されるメモリマップはこのスタック用領域が確保された後のメモリマップを表しており、未使用領域として扱われる三つのタイプのいずれでもないことが想定される。端的言えば、順番がカーネルファイルのロード→メモリマップの取得→カーネルの起動であり、ロード時に静的領域は確保されるので問題なし。
・なぜメモリマップ上で歯抜けの部分は使用中領域に該当するとみなされるのか
→メモリマップに記載されていない領域はオペレーティングシステムや特定のハードウェアコンポーネントによって予約されている領域であることが多いため
・64GiBまでアイデンティティマッピングしてるけど、物理アドレス足りてないがどうなるんすかね。超えてる分はページフォルトになるんかな
・FrameIDとはフレームインデックスの意　現在地を一フレームのバイト数で割ったもの、すなわち何番目（0番目から始まる）のフレームかを表している
・メモリマネージャーとかいうやつ、そいつが持ってるモデルに書き込みはするけど実際にメモリに割り当てて無くない？
→メモリマネージャーはあるサイズのメモリ領域くれっていわれたら、内部でメモリマップをみて開いている連続した領域を見つけてきて、メモリ全体の使用状況を表しているモデル中のその領域を表している箇所を使用中扱いにしてメモリマネージャーがその領域を空いているものと誤認することを防ぎつつ、それの先頭アドレスを持つFrameIDという構造体で返すもの。これは割り当てているのと同義。
・FrameIDのIDはインデックスのID
・メモリマネージャーが内部でもってるメモリマップはunsigned long(64bit)の配列で、それの一ビットずつがFrameIDと先頭から一対一対応している。（メモリマップは1フレーム(4KiB)が使用済みかどうかを1ビットであらわしたものの配列。フレームにはインデックスを表すIDがついており、それで何番目のメモリマップとフレームを対応させている。）

9章
・writeを呼び出すタイミングについて、修正前は描画を行うDrawToメソッド内でも行なっていたところ、FillRectangleやWriteAsciiなどだけにすることで再描画の際の処理を短くしたというもの。なお、透過色が設定されている場合はDrawToでもWriteを呼び出す必要がある
・ConsoleクラスはDrawをどこが担当するかという問題がある　Logを出力しようとするたびにそのクラスでDrawメソッドを呼び出すのは明らかにおかしいのでConsoleのなかでやりたい　ただそのためには自分でDrawができるようにlayer_managerを使ったり自分のlayer_idを持っていたりする必要がある　実際にPutString（）メソッドではグローバル変数layer_managerを使って自分自身をDrawする　ほかのWindowはなんかするたびにその場その場で利用しているクラスがDrawを呼んでいる ・Windowが持ってるshadow_bufferは型はFrameBufferConfigだけど、表しているのは単にそのWindowの画面情報で、当然bufferはそのWindowの左上のアドレスを表す 
・Windowクラスは画面の表示領域を表すクラスだが、部品的なウィンドウの要素も混在している（閉じるボタン等）
 ・WindowクラスのdataはTransparentColorが設定されている場合にのみ使うやつ。→いつでもshadow_bufferだけにできそう　Atだけ変えればいいんだから
 ・FrameBufferクラスはLoaderからもらったFrameBufferConfigもWindowがそれぞれ持ってるshadow_bufferも表せるけど、Copy（）メソッドは全画面の方しか呼び出さない想定（FrameBufferConfig持ってるやつかそのコピーであるback_buffer_持ってるやつ） 
・Positionはそれがどこにおける座標なのかを意識するとわかりやすい（例えば、Layerクラスが持っているposはFrameBufferConfig内での座標など。） 
・p.220 「new_posが末尾を指している場合（new_pos == layer_stack_.end()）」とあるが、この場合new_posは末尾の要素の次を指している。よって、要素が一つ少なくなった場合、new_posを2つ手前にずらす必要があるような気がする

10章
・Layerクラスのback_buffer_はLoaderからもらったFrameBufferConfigと全く同じサイズのもの。書き込む処理よりCopy（）メソッドのほうが軽いので、こっちに書き込んでからCopy（）をすることで上のほうのレイヤーが描画されていない瞬間を減らす 
・グローバル変数screen_configにLoaderから渡されたフレームバッファコンフィグが入っている
 ・グローバル変数screen_writerにLoaderから渡されたフレームバッファコンフィグを使ったピクセルライターが入っている
・C++で空白を表すのは''ではなく、' '


11章
・Timerは最初にLAPICTimerの間隔を測るために待機する必要があるところ、1秒も待つわけにはいかないため100ミリ秒待機し、それに10をかけることで1秒間のLAPICTimerの回転？数を確認している
・Timerはinitial_countに指定された周期で割り込みを発生させる。lapic_timer_freqの初期値は1秒分なのでkTimerFreqを1にしたら1秒に一度割り込みが発生する（LAPICTimerOnInterruptが呼び出される）ことになる。通常kTimerFreqを変更することはないのでデフォルト値の100、すなわち割り込みは1/100秒ごとに発生する
・Timerに設定するtimeoutは割り込みとは直接関係がなく、割り込みが発生した時に呼び出されるメソッド内でタイムアウトを判定するときに使われる。Timerに設定するtimeoutはミリ秒単位。kTimerFreqを設定すれば当然に1秒に一度タイムアウトが発生するのでそれを基準にかけたり割ったりすると使いやすい。

12章
・XSDT構造体は記述子の後に64ビットのアドレスが並んでいる　
・ポインタ + 1 はポインタの型 * 1だけ加算する
・XSDT構造体は記述子の後に並んでいる64ビットのアドレスは様々なデータ構造を指しているが、そのすべての先頭には記述ヘッダがついているので、各アドレスをDescriptionHeaderを指すものとしてキャストできる
・initial_countに設定した値の周期で割り込みが発生する

13章
・スタックは一番数値が大きいところを先頭として取得し、数値が小さいほうに向かって積み上げる（「積み上げる」とかいう言葉がおかしい。「下に伸ばす」とか「ぶら下げる」でいい）
・アセンブリ言語でpushやpop、callなどが実行されない限りスタックの値は変動しないので、アセンブリ言語を使えばSwitchContextメソッドのようなスタックの処理を実装できる。C++などではどこでスタックの値が変わるか制御することが難しい。
・アセンブリ言語での数値の単位はバイト
・RIPは次に実行する命令のアドレスで、RSPはスタックの最新の値
・PML4テーブルはページマップテーブルの最上位のやつ。ページング（メモリアドレス空間をページ単位で管理する）を設定するときにsetしたやつをTaskB用のコンテキストにも設定している
・leaは第二オペランドに指定されたアドレスをそのまま第一オペランドに設定するもの。movと違ってアドレスの先の値を取得しない
・call命令はスタックに戻り先アドレス（次の命令のアドレス）を自動的にぶら下げるので、call実行後に関数実行前のRSPを取りたいならぶらさげたアドレスの分上に戻れば良い（具体的には、64ビットアドレスなので+ 8すればいい）
・関数実行前のRIPとしてcall命令でスタックにぶら下げられた戻り先アドレスを保存しておく。普通はreturnしたらこれが勝手に実行されるので問題ないが、今回はreturnせず、自力で切り替えるので
・0x48-0x50間は8バイト
・task_b_ctx.rspの値を8の倍数にしているところについて、RSPをcallが実行された後のような顔にしたいのでこうしている。TaskBへの切り替えは手動せず　TaskBのRSPの値はcallを経由しないので
・プリプティブマルチタスクにするには、現在どちらのコンテキストにあったとしても実行されるような場所にコンテキスト切り替えメソッドを配置する必要があり、割り込み時に実行されるメソッドにて切り替えるようにする
・Main関数を動かしてるタスクのInitContext()が不要な理由は、当然に各種レジスタに既に値が入っているため
不思議→TaskBWindowをぐりぐりドラッグするとたまにWindiowの一部が移動前の場所にも残る

14章
・main.cppにて  timer_manager->AddTimer(Timer{kTimer05Sec, kTextboxCursorTimer});の前後にcli・stiが不要なのは、この時点では割り込みタスクが発生しないから（現状の割り込みタスクはXHCIとタイマーしかないので）
・dequeのpush_frontは先頭に要素を追加、push_backは末尾に要素を追加、popも同様
・写経ミスで謎のエラー発生。探していくと↓が原因だった
TaskManager::TaskManager() {
  NewTask();
  running_.push_back(&NewTask());
}
のNewTask（）を消し忘れたらタスクの切り替えができなくなった理由→多分、ここで作った二つのタスクのRSPの値がほぼ同じところを指しているはずで、それぞれスタック同じところ使っちゃうからめちゃくちゃになってどっかでエラー起きたんじゃないかな
・TaskManager::ChangeLevelRunningの現在実行中のタスクのレベルを変更する箇所について、
まず、running_フィールドひいてはTaskオブジェクトは、SwitchContext（）にてレジスタを書き換える際に、現在のタスクと次に実行されるタスクを同定しつつ、それらとして書き換え前後の値を保持するために存在している。
それを前提に、現在実行中のタスクのレベルを変更する箇所で行うべきことは、唯一SwitchContext（）を呼び出すSwitchTask（）メソッド内にて、現在のタスクと次のタスクを想定通りに取得できるような状態にrunning_を編集することである。ここで、現在実行中のタスクのレベルを変更した場合、SwitchTask（）メソッドではrunning[current_level_]の先頭を現在のタスクとしてまず取るので、指定したレベルのdequeの先頭に現在実行中のタスクを追加しつつ、current_level_を指定したレベルに変更すればよい。指定したレベルがcurrent_level_より低い場合、current_level_が最大のレベルではなくなる可能性があるので、level_changed_をtrueにして判定してもらう。
なお、先述の通り、running_フィールドはSwitchContext()を呼び出すためにタスクの順番およびレジスタの内容を保持するためのものであるため、running_の現在実行中のタスクの内容を書き換えたとしても既にSwitchContext()は呼び出し済みであるため、現在実行中のタスクに影響を与えることはない。→あるんじゃない？RIPとしてアドレス渡したメソッド内で仮にrunning_の現在実行中のタスクの情報が参照されていたら影響与える気がする。RIPまでが確定しててその先は動的に処理されると思う。

15章
・ここでやったことじゃないけど、FrameBufferWriterって誰が使ってるんだっけ
→RGBResv8BitPerColorPixelWriterとかが継承してる。これらはFrameBuffer::Initialize()メソッドのなかで作成されて使われている。細部までは最初から復習するときにみようか
・最初にTaskBWindowをActivateすると画面から消えて再び現れることがないエラー発生。なお、最初にActivateしなければ、起動後にクリックしてActivateしても正常に動く。
→差分を目視確認からのファイルを正規のものに差し替えとかいうロボみたいな解決方法を取ったが、解決せず。検索したらすぐ出てきた。- 2時間。思考停止すぎる。無意味な時間だよ。そもそも自分が間違えてたとしてもバグ調査を行うことで理解度を高めることができるっていうのに何をしてるんだよ俺は。何日までに終わらせるっつって計画立てることの負の側面が出た。以後気を付けよう。　
・TaskBをSでSleepしたらMainタスクもカーソルが点滅するときにしか動かなくなるのはなんで。なお、マウスを動かすとMainタスクも動く。
→前提として、Mainタスクは何も起きてないときはSleepで寝てる。だから何もおきてないときはテキストボックスのカーソルが点滅するときにしか動かない。TaskBは寝ないsudoでLAPICTimerの割り込みごとにSwitchTask（）で切り替えられて実行され、画面描画のためにsendMessage()を呼び出してMainタスクを起こす。なお、現段階ではTaskBはMainタスクを除けば最も高いレベルの単独のタスクなのでテキストボックスのカーソルが点滅していないときはずっとTaskBが実行されており、SendMessage()もループして呼ばれ続ける。SendMessage()が呼ばれると、画面描画が終わるまでTaskBはSleepするので、割り込みの時間に関係なく、TaskBとMainタスクが交互に実行されることになる。あと当然マウス動かしてもMainタスクは起きる。
→いやMainタスクもLAPICTimerの割り込みごとにSendMessageで起こされてないか
　→起こされていない。Tick（）内での条件分岐でLAPICTimerの割り込みの場合はSendMessageを呼び出していないので。LAPICTimer以外の論理タイマーがタイムアウトを迎えた場合にSendMessageが呼び出されるが、現状は論理タイマーはテキストボックスのカーソルの点滅タイマーのみ
・なぜかLoader側でAllocate Pagesに失敗するようになった。statusはNot Found
→心当たりなし。とりあえずmemmapの内容を確認したけど0x00100000はちゃんとConventionalMemoryになってた。num_pagesの値を出力してみたらA0000010となっており、kernel.elfのサイズが馬鹿でかくなってるかと思ったけどそういうわけでもなく、計算にバグがあるかあるいはPrintする過程でなぜか先頭がAに変わってるかなんかな。num_pagesを0x00000010にべた書きして差し替えてみたけどAllocate Pagesの結果はNot Foundから変わらず。kernel.elfのプログラムヘッダに記述されてる情報がおかしくなってるのかな。見当もつかないので差分確認したけど差分なし。終わった。一個前のコミットに戻ったら正常に動作するし、一個前のコミットに戻って差分を本家のソースに差し替えたら動作しなくなる。Printをばらまいてデバッグしたところ、0x6とかいうインデックスのプログラムヘッダがLoadセグメントにもかかわらずなんかわけのわからん仮想アドレスとサイズをもってるらしくMain.cのCalcLoadAddress()やCopyLoadSegmentsにおいて予期せぬ動作の原因になっている　マジでなんなんすかねこれ→Main.cだけ差し替えたら正常に動作するようになった。大昔に埋め込んだバグがついに活性化したってことか。どこにバグがあるか判別するために徐々に正規のMain.cに入れ替えていく。全部入れ替えても動作しなかった。差し替えミスだったらしい。もう何もわからん。とりあえず名指しでスキップするようにする。でもこれ毎回変わってたりしたらダルいな　LOADセグメントとしてなんか変なものが入ってきてるのは事実っぽいな

16章
・C言語の文字列は先頭要素のポインタで扱うが、その終端はヌル文字でのみ定められる。よって、任意の場所に後からヌル文字を挿入することで任意の場所で文字列を打ち切りにできる。逆に末尾のヌル文字を取り除くことで次にヌル文字が出てくるまでメモリをcharとして読み取り続けるとかいう危ないこともできそう。
・ターミナルの最大文字数は、ColumnはkColumns - 1と同じ(カーソル含めたらkColumnsと同じ)、RowはkRowsっぽい

18章
・shファイルのif文、[]の中のスペースが抜けがち。これ抜けると動作しない
・これ絶対前に調べたけど、もう一度書く。char* ptr = "文字列"とchar* ptr = なんかアドレスの動作について、前者はその文字列の先頭要素のポインタがptrに代入され、後者はアドレスがそのままptrに代入される。これらは一見すると全く違う動作をしているように見えるが、C言語では文字列リテラル（二重引用符で囲われたもののこと）は先頭要素のポインタとして扱われるので、これらが行っていることは右辺に記述されたアドレスを左辺に代入するという全く同じ動作である。なお、文字列リテラルは読み取り専用メモリに配置されるため、ptrを通じて文字列を変更しようとすると未定義の動作が発生する可能性があり、constをつけがち。
・これも絶対前に調べたけど、もう一度書く。ポインタにインデクサをつけると、（つけられたインデクサ * ポインタの示すデータの型のサイズ）だけポインタを加算して、そのポインタが指す値が返る。
char* p = first_arg;
while (true) {
while (isspace(p[0])) {
++p;
}
if (p[0] == 0) {
break;
}
argv.push_back(p);

while (p[0] != 0 && !isspace(p[0])) {
++p;
}
if (p[0] == 0) {
break;
}
p[0] = 0;
++p;
}

return argv;
}
の流れ（first_argとして"129 257 +"の先頭要素のポインタが渡されたとする）
p = first_arg; // p は "129 257 +" の先頭要素を指すポインタ

while (isspace(p[0]))) { ++p; } // p[0]は1であり、空白ではないのでスキップ

if (p == 0) { break; } // p[0]は1であり、ヌル文字ではないのでスキップ

argv.push_back(p); // p を格納（この時点では "129 257 +" の先頭要素を指すポインタであり、"129 257 +"までを一つの文字列として扱う）

while (p[0] != 0 && !isspace(p[0])) { ++p; } // pが空白を指し示す位置まで加算される（3バイト分足される）

if (p == 0) { break; } // p[0]は空白であり、ヌル文字ではないのでスキップ

p[0] = 0; //空白をヌル文字に置き換える。これで上で格納したポインタが指す値は"129"までに分離される。なお、ここでpの値を書き換えられるのは、"129 257 +"が文字列リテラルではなく、変更可能な配列として定義されたline_buf_の一部であるから。

++p; //元空白、現ヌルの次の要素を指し示す位置にpが加算される（p[0]が2になる）。次のループへ

限界エラー発生　なぜかQEMUが再起動する　今回の修正を差し替えても変わらず
→デバッグを繰り返すうちに、rpnを実行した後にメインタスクに戻ってくるタイミングで再起動が発生していることが判明　ためしにメインタスクの間隔をクソ広くしたらそれはそれで正しい結果が出るわけでもなかった　どういうことやｊねん　間隔でなんかなってる→vectorとかを解放するときにエラー発生してる説
コメントアウトしながらデバッグ実行することによりrpnの実行のみがおかしい　そこでエラーが発生していることが判明　ELFの定義ファイルがおかしいのかと思ってelf.hppみてみると案の定違うところ発見。差し替えて実行するもエラーは変わらず　ここじゃないらしい　なお、15章のやつは差し替え前からエラー発生しなくなってたどういうことやねん　
entry_addrの計算結果がおかしい説は1つ極めて有力
デバッグの結果、e_entryが0x1220、&file_buf[0]が0x1136090とのこと　後者でかすぎない？
とりあえず&file_buf[0]付近の値をとってみたら&file_buf[0]からマジックナンバーがあり、ロードはされてるっぽい（まあifの条件文パスしてるからそうに決まってるんだけど） e_entryの値がおかしいみたいだ　elfファイルをreadelfしてみると、Entry point 0x1220と表示される　うーんここまであってるな
てかこれどうやってロードされてるんだっけ　onlyhltとかrpnって使うときに初めてロードされる感じ？
そう　いやこれ次の回の内容ちらっと見た感じこれっぽいな　普通に3章の後動かなくなってたのと同じ原因のやつでは。19章を進めて動くか確認することにする。

19章
・「page_map_levelが2のときは最大で512ページしかマップできません」これ、entry_indexが511に達したらbreakするから最初が0だった場合に最大の512回しかSetupPageMap()を呼び出せないってことか
・「要するに桁の繰り上がり処理ですね」これについて、2以上のレベルのときにこの箇所にまで到達するのは現在のentryindexが指しているより下位のページマップをすべて使い切ったか、あるいはnum_4kpagesが0になる、すなわち指定されたサイズのデータを格納するに十分なページマップの設定が完了したことを表している。前者の場合、entryindexを一つ上昇させることになるが、その際より下位のレベルのentryindexをリセットしておかないとffffから始まることになり一つのページしか設定できなくなるのでリセットしている。後者の場合、この値はもう使わない（addrの一部、entryindexが意味を持つのは新たにページマップを作成し、それに紐づける時だけ）ので場合分けせずにリセットしてしまってよい。
・一つのページマップごとに1FrameしかFreeしてないけどいいのか→1Frame4KiBと定義してるのでちょうど一つのページマップと一つのFrameが対応することになるのでおｋ。（一つのページテーブルは基本的に4KiBの物理アドレス空間を表すっぽい）アラインメントはあってるの？→そもそもページマップをmemory_manager->Allocate(1)で生成しており、一つのページマップが指し示すアドレスもreinterpret_cast<PageMapEntry*>(frame.value.Frame())（Frame()の実装はreturn reinterpret_cast<void*>(id_ * kBytesPerFrame)）なのでentry_addr / kBytesPerFrameは余りが出ない（idがそのまま出るはず）。
・ページングの階層について、pml4テーブルだけは既にできてるってことだよね？
・ページングについて、基本的にすべてのアドレスが仮想アドレスとみなされて、ページングテーブルによって解釈されて物理アドレスに変換されるっていう認識でいいのかな。でもそれだったら普通にメモリアロケートして使ってる部分、ページングの設定してないからページフォルトになるんじゃないの→8章でアイデンティティマッピングしてたわpml4テーブル[0]だけ全部設定してた。
・CleanPageMaps（）について、ここではpml4_tableを一つしか使ってない仮定のもとFree（）している。pml4_tableの指定したインデックスに紐づけられたすべてのpdp_tableを、それにページディレクトリが紐づいていようといまいとお構いなしに解放している
・相変わらず動かない　調べてみたらやはりlld.ldのバージョン違いが原因のエラーがあるらしい　確かにreadelfしたら4KiB境界にないわ　それの通りに修正しても動かない　正規のterminal.cppに差し替えたら動いたので嘆きながら目視でみてなんも違いみつからず、ちょっとずつ差し替えてエラーがある範囲を絞り込んでから目視で確認してやはり何も違いみつからず激萎え　AIに聞いたらbitsのwritableを設定する一行が抜けてるとのこと　そこを修正したら遂に動作した　マジ目視確認の無力さよ
・リンカが具体的にどんな動きをするからこの不具合が発生するのか。
Read + Exec権限のLOADセグメントの仮想アドレスが4KiB境界にない。
てかなんで4KiB境界にあることを前提にしてるんだ→ld.lld7はLOADセグメントの仮想アドレスを4KiB境界に設定するので
・なぜ4KiB境界にないと動かないのか。
ページ数の計算は従来 
const auto num_4kpages = (phdr[i].p_memsz + 4095) / 4096;
であり、これはphdr[i]が示すLOADセグメントが4KiB境界に位置していることを前提としている。そのため仮にLOADセグメントの場所が4KiBの境界になく、かつ同じサイズのLOADセグメントが4KiB境界にあった場合よりも多く4KiB境界をまたいでいた場合に、設定が必要となるページ数が不足し、無効なエントリが表す仮想アドレス範囲に対して読み書きを実行することになりページフォルトが発生する。
・修正コードでなぜ修正しきれるか。
修正コードは
const auto num_4kpages = ((phdr[i].p_vaddr & 4095) + phdr[i].p_memsz + 4095) / 4096;
であり、(phdr[i].p_vaddr & 4095)は仮想アドレスと0xfffのAND演算すなわち下位三桁の抽出であり、これは4KiB境界からのオフセットを表している。これでどの場所にLOADセグメントがあっても必要なページ数を計算できるため、ページフォルトは発生しなくなる。
LOADセグメントが4KiB境界に配置されないことがあることのみがエラーの原因であり、その他の要素はlld.ld7と変化していないためこの修正でエラーが解消される。
・3章のエラーとの関係について。
3章のエラーは、elfファイルそのものを直接メモリ上にコピーし、elfファイルのオフセット24バイトの位置にエントリポイントアドレスが記述されていることを利用してelfファイルのmain関数の位置を特定していたが、仕様ではここに記載されているエントリポイントアドレスはelfファイルをロードした後のエントリポイントアドレスを指しており、elfファイルをより小さくコンパクトにリンクするようになったld.lld14では実際のelfファイルとロード後のelfファイルの構成が異なっていた（実際のelfファイルはいろいろ詰めて構成されてるのでロード後のエントリポイントアドレスよりずっと前の位置にmain関数が置かれていた）ことが原因だった。これは4章でプログラムヘッダを読み取ってLOADセグメントをロードするようになって解消された。
なお、ページングについては3章時点ではメモリマネージャーを使っておらず、指定したサイズで読み込んでもらってるだけなので、対応しているFrameとかもない。そのためどのFrameを使用可能な状態にするかの計算は不要で、4KiB境界は関係ない。すなわち、原因は別。
・15章で発生した謎のエラーとは関係なさそう　あれなんだったんすかね　typedef uint32_t	Elf64_Word;がそれまで間違えてuint16_tになってたことが原因説はちょっとある

20章
・retfはRIPに積んだ値にジャンプする。引数について、仕様で左から順にRDI、RSI、RDX、RCX、R8、R9の順にレジスタに入る
・reinterpret_cast<char**>(args_frame_addr.value);
について、args_frame_addr.valueを、一つ一つの要素がcharの配列を指すアドレスの配列の先頭要素のアドレスとしている。
・CallApp()の呼び出し時の引数として、entry_addr（RIP）、stack_frame_addr.value + 4096 - 8(RSP)を渡している。次に実行する命令がrpn（読み込んだelfファイルのエントリポイント）なのでentry_addrを渡し、スタックポインタ（現在のスタックの一番低い値）として引数用に作ったページの次に浅いところ（まあ別にどこでも良かった）に１ページ分設定してそのページのうち8バイト境界かつ最も高位のアドレスを渡している。スタックは高位→低位で進んでいくので設定した1ページの最も高位のアドレスかつ8バイト境界のものを渡している。8バイト境界にして渡している理由は、System V AMD64 ABIではある関数からほかの関数を呼ぶときはスタックポインタの値を16バイト境界に揃えておくことが定められていてそれにしたがってコンパイラは関数の先頭ではスタックポインタの下位4ビットの値が8になっていないと例外を発生させるので、ここではcall命令を使わずにジャンプしているためcall命令の分手動で8バイトプッシュしたみたいにしてやる必要があるから。
・20bで無限ループ入らずに再起動してしまう。原因不明。本物の20bチェックアウトして4KiB境界のとこだけ修正して実行したらそれも再起動したのでいったん先に進めることにする。
・20.3 『TSSを設定しよう』について、読んでてもよくわからなかったので考えて言語化する
これまでのコンテキスト切り替えは、割り込みハンドラの途中で、その時点のレジスタ群を保存しつつ指定されたコンテキストのレジスタに値を書き換えるSwitchContext()というメソッドを実行することによって行われていた。
コンテキストを切り替えた後の流れは、SwichContext実行直後を示すレジスタ群を利用して、自動でスタックフレームを辿って割り込みが発生する前に戻っていくというものであり、具体的にはSwichTask()のスタックフレーム→LAPICTimerOnInterruptのスタックフレーム→IntHandkerLAPICTimerのスタックフレーム→割り込みスタックフレーム→割り込み前、の流れで割り込み発生前に復帰する。
ここで、割り込みスタックフレームは通常は単に復帰のための40バイトのスタックフレームを積むというものであるが、
CPL3からCPL0に切り替わる場合はRSPにTSS.RSP0の値が代入されてから40バイトのスタックフレームを積む仕様になっている。すなわち、CPL3からCPL0に切り替わった後のスタックフレームはつねに同じ場所を使用することになり、保存しておいたレジスタ群の指す場所が上書きされてしまい、スタックフレームを辿る形で復帰することが不可能になってしまう問題がある。
そこで、割り込みスタックフレームに保存されているレジスタ群の値を保存する形で切り替えることにする。つまり、コンテキスト切り替え後の復帰の流れを直接割り込み前にジャンプさせる（ジャンプはしてないけどレジスタが割り込み前の状態に戻ってる）形にまで短縮する。
・忘れたのでこれまでのコンテキスト切り替えの復習
　・タスクの切り替えは、先頭要素が実行される性質を持つ実行待ちタスクの配列の先頭を入れ替えるという形で表現されている。この入れ替え処理は一定時間ごとに呼び出される割り込みハンドラとして定義されており、そのハンドラの内部でその時点のレジスタ群を保存しつつ指定されたコンテキストのレジスタに値を書き換えるSwitchContext()というメソッドが呼び出される形でコンテキスト切り替えが行われている。
　・現状、タスクはTaskManagerがNewされる（TaskのInitializeTask()）ことによって生成されるメインタスクとmain.cppで追加されたterminal用のタスクの二つだけ
　・タスクが起動する流れとしては、割り込みハンドラあるいは起動中のタスクによって、指定したタスクが実行待ちタスクの配列の末尾に追加され、時間経過で実行されるというもの。
　・Sleep（）メソッドを呼び出すことで指定したタスクを実行待ちタスクの配列から除去することができる。このとき、指定されたタスクが実行中であった場合次のタスクに切り替える必要があり、そこでもSwitchContext()が呼び出されている。Sleep（）メソッドは割り込みハンドラから呼び出されることがないので、コンテキストを共用する可能性がなく、これまで通りのSwichContextメソッドを使う。（現在のレジスタを保存する必要があるのでRestoreContextだけでは機能しない。あと、割り込みスタックフレームがないのでIntHandlerLAPICTimerのロジックを使いまわすこともできないため、SwitchContext()にはこれからもお世話になることになりそう）
・図20.7の「これまで」図でTaskContext::rspに保存する値がSwitchContextのスタックフレームの最も高位の場所になっているのは、レジスタ群をSwichContextから一つ前のスタックフレームに戻る処理を実行する直前の状態にしたいから。この部分はこれまでなので当然13.2から変わってない。
・再起動する問題　これメモリのアドレス4から8が0じゃなくてページングが設定されてないところなんじゃない？
・IntHandlerLAPICTimerについて、rbpには開始時点でのrsp（最も低位のアドレス）が入っているので、rbp + 0x08等は開始時点より上の領域、すなわち一つ上のスタックフレームを参照している。一つ上のスタックフレームには割り込みスタックフレームがあるので、そこから値をとってきてるっていうこと。それ以外のレジスタは手動で取る必要があるのでここで保存してる。
・関数呼び出し前後で内容が保証されるレジスタ（Callee-Saveレジスタ）
・構文についてはあんまり覚える気ないけど、#defineを用いたマクロ定義は基本的に一行で行われるのでバックスラッシュで複数行連結する
・
#define SYSCALL(name) int64_t name( uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6)
はSYSCALL({名前})で｛名前｝という名前のuint64_tの引数を6つもつ戻り値int64_tのメソッドを宣言できるようになるマクロ。
・InitializeSyscall()内のCS、SSへの設定について、下位2ビットは0にして下位3桁目から見る。100が1扱いになる。
・WriteMSRについて、まず前提として、第一引数はediレジスタに、第二引数はesiレジスタに入る（64ビットの時はrdi、rsiに入る）。また、RDXの下位32ビットをEDXと呼ぶ。shr rdx, 32はrdxの上位32ビットをedxに格納する命令になる。
・SyscallEntryについて、システムコール番号は0x80000000から始まるのでこれが0になって、0x80000001が1になればいいので、最上位の8だけをマスクするために0x7fffffffをandする。
・fxsave ｛オペランド｝はオペランドで指定された場所にx87 FPU、MMX、SSE、SSE2等の情報を格納する
・TaskManager::SwitchTaskの if (&CurrentTask() != current_task) は現在実行中のタスク列の先頭と、現在実行中のタスク列の先頭を一度popした後の先頭を比較して異なっていたらという条件。現在実行中のタスク列に要素が一つしかなく、その要素がsleep状態ではない場合にはコンテキストを切り替える必要がないのでこのように分岐させている
・20eまで写経したらエラー発生。差し替えて確認するとterminal.hppを差し替えたら解消することがわかった。差分を確認するとコメント以外は何もなく途方に暮れていたが、差し替え行為（.oファイルを削除してビルドしなおすこと）自体がエラーを解消していたことが判明。時間を返してください。差し替えで解決試みるの不毛すぎるけど期限というものがあるからね。

21章
・rpn/newlib_support.cのstruct SyscallResult SyscallPutString(uint64_t, uint64_t, uint64_t);はSyscallResult構造体を返すメソッドのプロトタイプ宣言。プロトタイプ宣言をすれば#includeしなくても使えるので、ヘッダファイルをこれだけのために作るのではなくプロトタイプ宣言で済ませてるんだと思う。
・XHCIのハンドラのほうにはISTを設定しなくてよい理由は、当然こちらはコンテキストの切り替えを行わずcr3が更新されることもないため。
・Terminal::Print()について、現状のPrint()は再描画処理を含まないので単体で機能させるには再描画処理を記述する必要がある→Print（）は大きく分けて、Terminalの作成時とキーが押下された時の二つの場所で使われているが、当然どちらもその後に必ず再描画処理が入る。
キーが押下された時のTerminalの再描画の流れ
キーボードの任意のキーが押下される→XHCIの割り込みが発生する→Mainタスクにメッセージを送信し、Mainタスクを起動する→Mainタスクがwhile中のswitch文でメッセージがMessage::kKeyPushだった時の処理にジャンプする→その処理中でActive状態のlayerを探してそのLayerのタスクにメッセージを送信し、そのタスクを起動する→Teminal::TaskTerminalのwhile中のswitch文でメッセージがMessage::kKeyPushだった時の処理にジャンプする→InputKey()を呼び出してteminalのWindowの画面情報を書き換える（ここでの処理にPrint()を使う）→MakeLayerMessage()を呼び出して画面再描画用のメッセージ（Message::kLayer）を作成する→作ったメッセージをMainタスクに送信し、Mainタスクを起動する→Mainタスクがwhile中のswitch文でメッセージがMessage::kLayerだった時の処理にジャンプする→画面を再描画する処理を含むProcessLayerMessage（）を呼び出してから、Message::kLayerFinishを起動中のタスクに送信して画面描画が完了したことを伝える
・layer_manager->Draw()は再描画する
・「アプリ用コードセグメントとスタックセグメントを別々に指定できました。しかし、syscallを使う以上は2つを別々に指定できる意味がありませんので、スタックセグメントのセレクタ値だけを指定できるようにしました」→どういう意味？あとこの二つともWriteMSR()で指定してるんだから必要ないんじゃないの？→まず、コメントの意味について、CallAppを呼び出して設定するSSとCSが指すアプリ用のセグメントディスクリプタは、syscallを使う都合上GDT上でSS、CSの順で並んで配置されるのでSSの値だけわかれば後は3bit先にCSがあるので、8をaddすることでCSに設定すべき値を算出できる。WriteMSR()について、これはアプリ内でsyscallが呼ばれた時の設定であり、アプリが起動してからsyscallを呼び出すまでの間のSSとCSの設定をCallApp()で行う必要がある。
・基礎知識。SSとCSはそれぞれセグメントを指定するためのレジスタであり、具体的なセグメントの指定はこれらのレジスタの3から15ビット目でGDTのインデクサとなる数値を指定することによって行われる。GDTはセグメントディスクリプタの配列である。セグメントディスクリプタはセグメンテーションに関連するの様々な設定（権限レベルなど）が集まったもの。セグメントディスクリプタは全体の設定を表すものであり、区切られた区間などの一つ一つを表すものではない。

22章
・WinDrawLine()でなぜdx、dyに正なら1、負なら-1を足しているのか
→ピクセルベースのディスプレイであればdx、dyともに大きな数字になることがほとんどで、そのような場合において両者に1が加減される程度のことでは大した視覚上の変化はなく、それよりも線の終点を含めることを優先したんだと思う。
・アプリがmain関数の引数として渡されるargcはコマンドのオペランドの数+1(コマンドの分)を表している
・CloseWIndow()でactive_layer->Activate(0)をしている理由
→Deactivate（）したいため。Activate()メソッドの引数に0をいれると、アクティブ状態のものがあればそれをDeactivate（）するという処理になる
・ターミナルから起動した各種アプリのタスクはターミナルタスクで共通してるんだよね。そのうえでlayer_idで閉じるウィンドウを指定してるっていう認識でいいのかな。
・基本中の基本だが、push raxとするとき、ここでpushされてるのはraxレジスタの中身。mov rdx, [rsp + 8]とはrspの値に8を加えたアドレスを計算し、そこから8バイト分の値をコピーしてrdxレジスタに格納する。スタックとレジスタについては、スタック領域とそれとは別の場所にあるレジスタを想像するとわかりやすい。ときにスタック領域にレジスタの値を入れてみたり、レジスタにスタック領域のアドレスをいれてみたりする感じ。双方は相互作用する使い方をされるものだが、そもそも独立して存在している。
・OSStackPointer()の中身っていつ設定されてるの→CallApp()内で設定される
・Task.Sleep()の問題ってどういうこと？→Task.Sleep()中ではSwichContextが呼ばれる。SwitchContext()は第二引数に現在のレジスタを保存し、iret命令のためのフレームをアプリのスタック上にpushし、現在のレジスタに第一引数の値を渡し、iretを実行することでコンテキストを切り替えている。ここで、第一引数のレジスタ群のCR3はTaskManager::RotateCurrentRunQueue()にて設定された次のタスクのコンテキストのCR3の値が入っており、ページングテーブルの後半部分はアプリごとに異なるので、iretを実行する際のページングテーブルは元のページングテーブルと異なったものになる。システムコールはRSPがあるアプリのスタックを指している状態で行われるので、iret命令のためのフレームはそのアプリのスタック上に積まれることになる。ここでiret命令（スタックポインタ（RSP）を介してスタックにアクセスする）が実行されると、現在のRSP値がページングテーブル上に存在しない値になっているためにページフォルトが発生する（writableが1になってないので）。iret用のフレームは常に固定のページングテーブルであるOS側にあるべきだってことね。これに対するOS本の対処法は、システムコール実行前にRSPの値をOS側のスタックに切り替えるものだった。

23章
・active_layer->GetActive()はアクティブ状態のLayerのIDを返す
・eyeとpaintは新しいことを何もしていない。それぞれコマンドが実行されたらシステムコールのReadEventを呼び出し、呼び出されたシステムコールのReadEventのタスクは待機状態になり、マウスに動きがあると割り込みハンドラにてアクティブなタスクに対してSendMessageが実行され、システムコールのReadEventのタスクが起動してそのMessageを解釈してアプリに返り、アプリは処理を行った後、再びシステムコールのReadEventを呼び出し、以下ループが続く。
・atoi()は文字列である引数を数字として解釈することにより作成されるint値を返す
・Timerのvalue_はタイムアウト時に通知される値を表す。valueの扱い→システムコールのCreateTimerを呼び出す引数は普通に正の値で、この中からTimerにAddするときにマイナスをつけて負の値にする。システムコールのReadEvent中でメッセージを受け取ったときに、valueが負であればアプリから設定されたTimerとして処理する。
・durationは間隔を意味する単語 
・アプリの待機時間にキーを押下・解放あるいはマウスを動かすとunknown event:となる問題→仕様。そういう動作するとReadEventでそのイベントが設定されてしまうので、ReadEvent使ってるアプリではswitchでdefaultにいってそのログが出てしまう。あといろいろ動かしてると一般保護例外が出るのも仕様っぽい

24章
・従来の階層ページング構造の設定の流れ
アプリをLoadする際に、プログラムヘッダを読み取って仮想アドレスやサイズを把握→階層ページング構造の設定→LOADセグメントのコピー
・階層ページング構造の設定について、具体的には与えられた仮想アドレスから必要なページング構造を遡りながら作成していく。遡るときの原点は設定済みのPML4テーブル。
作成について、指定されたページマップの一単位（ある仮想アドレスが与えられたらそれから必要な4つのテーブルは一意に決まる）が指す下位のページマップの一単位のpresentフラグが立っていなければmemory_managerのAllocateメソッドを呼び出して開いている領域にFrameを作成し、そのFrameのアドレスをそのページマップの一単位に紐づける流れで行われる。その一連の流れを与えられたページの数の分繰り返す。
・従来はPML4テーブルを一つのみ作成し常にそれを設定していたため、すべてのアプリの仮想アドレスに対応する物理アドレスが常に同じであった。よって、アプリを終了することなく（終了するとページマップが削除される実装になっていた）次のアプリを実行するとエラーが起こりがちだった。
・ExitAppの第二引数に渡したものが、ターミナルにてret = ｛引数で渡したもの｝という形で表示される理由→ExitAppは第二引数をeax、すなわち戻り値用のレジスタに格納してから、CallApp関数が終わった場所までジャンプするので、第二引数に渡したものがCallApp関数の戻り値として解釈される。
・ExitApp関数のretでCallAppの次の行に飛べる理由
→前提として、ret命令は現在のRSP（スタックポインタ）が指すメモリアドレスから8バイト値を読み取り、その値をRIP（命令ポインタ）に設定してジャンプするというもの。アプリが起動されるときはCallAppが呼び出されて、その中でretfを実行することでアプリ用のスタックに切り替わっている。よって、ExitApp内でOSStackPointerの値にRSPを戻した場合、CallAppにてmov [r9] rsp（ここでOSStackPointerに現在のRSPを入れてる）を実行した時点のスタックに戻る。そのスタックにはR15やR14などが積まれているのでpopで順番にそれらをすべて取ったら、CallAppの呼び出しをした時点と同じRSPの値となる。ここで、関数の呼び出しを行う場合、CPUはその関数の処理を実行する前にまずスタックにその関数実行後の復帰先アドレスをプッシュするので、RSPがその状態でret命令を実行した場合、CallAppの復帰先アドレスにジャンプすることになる。
・SyscallEntryのExitを上書きしてしまって良い理由→Exitシステムコールは戻り値二つ持ってて、それぞれCallAppで設定されたOSStackPointerの値とCallApp関数の戻り値にするものが入ってる。そんで戻り値が二つある場合、それぞれraxとrdiに入るのでそれらを引数用のレジスタにコピーしてやってるのでそこからはExitAppと処理を共通にできる。

25章
・FormatName関数について、ReadName関数が第二引数に拡張子前の名前、第三引数に拡張子の名前を格納するものなので、単純に呼び出した後それらを連結させている。
・fat::NextCluster関数が次のクラスターを返す理由は、FATの設計として各クラスタエントリが「次のクラスタ番号」を保持する連結リスト構造になっているから、fat[cluster]で取れるってだけ。
・FileDescriptor::Read関数にてrd_cluster_が0かどうかで分岐しているのは、rd_cluster_の初期値が0だから。
・GetSectorByCluster関数はクラスター番号からそのクラスターの先頭アドレスを取得する
・OpenFile関数の戻り値の一つであるDirectoryEntryをFileDescriptorとして配列に格納できる理由→std::make_unique<fat::FileDescriptor>(*dir)は*dirを引数としてfat::FileDescriptorのコンストラクタを呼び出して作成したインスタンスを返すものだから。
・posix_memalignについて、(void*)((addr + alignment - 1) & ~(uintptr_t)(alignment - 1));の意味→前提として、この処理はアライメントの調整を行うものであり、アライメント境界を2の累乗と想定している。その上で、ここではまずaddrにalignment - 1を足すことでこの処理後に返る値がaddrを下回ることが決してないようにしている。そのうえで、2の累乗であるアライメントから1を引いた数(2の累乗はその一番上のビットのみが1で下位ビットがすべて0になっており、そこから1を引くと一番上のビットは0でその下位ビットがすべて1になる)のビット反転をしたものは下位ビットがすべてゼロになる。それとAND演算を行うことでアライメントの調整を行っている。
・static宣言が付いた静的な変数初期化は、二回目以降は実行されない
・explicitをつけると暗黙的型変換ができなくなる
・Task::files_は0個で初期化されてその後追加される実装もなさそうなのでAllocateFD()は現状常にemplace_backしてそれの添え字を返すことになりそう
・FileDescriptorの内容についても、file_entry_以外はコンストラクタで設定されないので他全部初期値になる。クラスターのオフセットも当然設定されないが、この場合FileDescriptor::Read関数にて、len - totalのほうがbytes_per_cluster - rd_cluster_off_よりも大きい場合、クラスターの先頭からコピーされることになる。ファイルが必ずクラスターの先頭に配置されているなら問題ないけど、そういう処理になってたっけ。なお、現状クラスターをまたぐようなサイズのファイル（len - totalのほうがbytes_per_cluster - rd_cluster_off_より大きくなるもの）がないから問題は顕在化しなさそう。

26章
・C言語の標準ライブラリ（stdio.h）では標準入出力はアプリのソース側からは入出力先がなんであろうとファイルのように扱える仕様になっている。キーボードから入力させたい場合は、あるファイルの内容を読み取りたいかのような書き方で標準入力を使うことでキーボードから入力させることができる。あるファイルに出力したいかのような書き方で標準出力を使うことでターミナルに出力させることができる。まあ、必ずしもキーボード・ターミナルとは限らないわけだが
・標準というが、これはＣ言語ではscanf()の読み取り元、printf()の出力先、perror()の出力先をそれぞれ標準入力・標準出力・標準エラー出力と呼称しているだけのもの。入出力を扱う時に使うprintf()やscanf()などの高レベル関数は内部でファイルディスクリプタ番号を指定してシステムコールを呼び出しており、それらとシステムコールによって指定されている入出力先が標準入出力ってこと。何も考えずにprintf()やscanf()を使ったらそこにつながるので「標準」。
・ファイルディスクリプタ番号はOSのシステムコールを呼び出す際の引数として渡すことで、ファイルを指定するための値。こちらがOSを作ってて、newlib_support.cも記述する立場にあるなら標準入出力のファイルディスクリプタ番号はなんでもいい。例えばnewibを利用してprintfを実装しているなら、まずOSにて引数としてファイルディスクリプタ番号80が与えられたらそれをターミナルの出力とするシステムコールを定義したうえで、newlib_support.cに記述したwrite()の中でファイルディスクリプタ番号（引数）を80にしてOSのシステムコールを呼び出しても何の問題もないわけですよね。ただ、newlib使ってるならwrite()には引数として1が渡されることになるし素直に1にしとくかってところ。最悪ファイルディスクリプタ番号がなくてもprintfからwrite経由してシステムコールでターミナルに出力する流れは成立させられるので標準出力が実装できると言えなくもないが、そうなると何が標準やねんという概念的な問題が出てくる。
・「Newlibのprintf()関数は最終的に、標準出力(fd = 1)に対してwrite(1, ...)を呼び出します。if(fd == 1)と書いたのは、fd＝1に対するwrite()が実行された結果、syscall::PutString()の変数fdの値が1になるからなのです」について、まず、PutStringシステムコールを作成したのはこれを呼び出すwrite()メソッドを作成することでprintf()関数を利用できるようにするためである。すなわち、printf()を実行する場合、write()の第一引数に1を必ず設定するためそれ経由で必ずPutString()のarg1も1になるはずで、その場合にターミナルに出力するようにしたかったっていうこと。fdが1になる場合はターミナルに出力するっていう処理をいろんなところで書くことになるのかな。→ここで設定したものを標準出力と呼称し、printfを使って呼び出すので基本的に他でfdが1ならターミナルに記述するみたいな処理は書かない。そういうのをシステムコールではやらない。アプリ側がやることなので。
・TerminalFileDescriptor::Read関数にて、終端文字として0を返しているとのことだが、コントロールd以外で終端文字返しそうにないけどいいんですかね→これはキーボードからの入力を処理するRead関数であり、キーボードで終端文字打てないから問題ない。newlibのfgets()はread()の戻り値が0だったら終端文字とみなして読み込みを止めるので0が適切
・ディレクトリエントリのnameの先頭1バイトが0xe5だと未使用扱いなんだっけ→0x00 は未使用エントリ、0xe5は削除ファイルを表す
・ExtendClusterでfat配列の2番目の要素から探索してるのはなんで→クラスタ0と1は特別な意味を持つため使用禁止なので
・ファイルディスクリプタについて、これの先頭は論理ファイルの先頭からの距離としても実際のクラスタ番号やそのクラスタの先頭からの距離としても定義されているが、末尾はどうなってるの→
・ファイルディスクリプタのrd_off_ってなんすか。ファイルの先頭からの距離っていうけど、これ自体が論理ファイルなんじゃないの。一つのファイルディスクリプタが一つのファイルを表すんならその先頭からファイルなんじゃないの→Readは指定された量だけ読み込むメソッドで、これを繰り返し呼ぶ用法を想定している。そのため、前回のReadでどこまで読んだかを保存しておく必要がある。
・ファイルディスクリプタはファイルを操作するために作られる論理的な構造であり、ディレクトリエントリはFATファイルシステムの一部として使われる実体。前者はアプリごとに作られるが、後者は一つのOSで共有される。ファイルディスクリプタはディレクトリエントリを引数とするコンストラクタを使って作成され、ディレクトリエントリへの参照を持つ。
・cpコマンドの流れ→fopenで二つのファイルが開かれる。fopenはopenを読んでおり、openはOpenFileシステムコールを読んでいる。OpenFileシステムコールでは、指定したファイルがあればそれをなければ新たに作成して、現在のタスクのファイルディスクリプタ配列に追加する。作成する関数では、指定したクラスタ及びそのクラスタに連なるクラスタチェーンのなかに開いているディレクトリエントリがあればそれを返す（なかったらクラスタチェーンに新しくつなげてそれを返す）。その後freadでバッファにコピー元が読み込まれ、読み込んだ量がbytesに入る。その後、fwriteでバッファの内容をbytesだけコピー先に書き込む。
・FindFile関数はディレクトリのパスであったとしても普通にそのディレクトリエントリを返す。CreateFile中では第二引数に何も設定していないのでルートディレクトリから順にさがしてあればそのディレクトリエントリを返す内容になっている。
・CreateFileは単に、与えられたパスをディレクトリとファイル名に分けてディレクトリからそのディレクトリエントリを取得し、そのディレクトリエントリにファイルを新たに追加する。そのファイルのディレクトリエントリの名前がファイル名になる。

27章
・sbrkはSyscallDemandPagesが前回のデマンドページング領域の終端を返すから、それに今回分を足してる。
・sbrkにてprogram_breakにincrを足している理由→既に確保されているデマンドページ用のメモリと、確保が必要なメモリが別に存在している。sbrkの引数に渡されてきたバイト数は毎回可算していき、それが確保されてるデマンドページ用のメモリを超えたらデマンドページ用のメモリを増やす必要がある
・デマンドページこれひたすら伸ばしていくことになってるけど、途中で利用されてる領域が入ったらどうするんだろ→設定されてる値でわかるけど、ここで設定しているのは仮想アドレスなので実際に物理アドレスでは途中では利用されてたとしても問題ない。仮想アドレスのアプリ用のテーブルはアプリごとに存在するので、起動時にアプリのファイルを読み込んだ後の地点からは広大な使われていない領域が広がっているはず。
・ソースコード上のアドレスが仮想アドレスを表しているのか物理アドレスを表しているのか確認する方法はある？→プログラムは仮想アドレスで書いて、内部的にページマップを使って物理アドレスに変換されて処理されることになるので、基本的に物理アドレスを記述するのはページング構造の最下層に設定するところだけ。
・デマンドページ用のメモリの位置としてアプリ用の仮想アドレス設定しちゃってるけどいいのか→アプリから呼ばれるシステムコールでのみ使う予定なので問題なし
・PreparePageCacheでm.vaddr_beginの方がpage_vaddr.valueよりでかくなることはないんですかね→ vaddr_beginも4KiB境界なのでpage_vaddr.value の4KiB境界のオフセットを0に加工しても最小でm.vaddr_beginと同じ値にまでしかならない
・OpenFileシステムコールの後、普通にストリーム方式で読み取る時ってどっから読むんだっけ→OpenFile内でファイルが格納されているアドレス情報を含むディレクトリエントリが現在のタスクのファイルディスクリプタ配列に追加されつつ、ファイルディスクリプタ番号が帰るので、それらを利用して普通に読み取る
・ここでいうメモリマップトファイルは仮想アドレス空間で連続するように実際にメモリ上にファイルをコピーしてるみたいなものっぽい。デマンドページングみたいな仕組みにはなってるけど、実質的には仮想アドレス空間にファイルがぽんと置いてあるようなものに見える。これをやると、任意の位置を簡単に読み込んだりできるわけだ。これまでに実装してきた読み込みや書き込みは先頭から順に読み込むことを想定しているのでランダムアクセスは不得手。標準のfgetsとからへんの実装に指定した位置から読み込むみたいな使い方がないので、これらを利用したいならreadとかwriteにはランダムアクセスを想定した引数を用意できず、シーケンシャルになる。なお、このOSではシーケンシャルな読み込み・書き込みを勝手にOS側でreadやwriteが実行されるたびに現在の読み込み・書き込み位置を示す変数を変化させることで実装している。
・Loadapp()内の、app_loadsに存在しないアプリケーションだった場合にひな形を挿入する処理について、挿入後に挿入した変数が変更されているがこの変数はポインタや参照ではなくオブジェクトなので挿入後に変数を編集しても影響はない
・「この時点で app_Load.pml4が指す階層ページング構造の後半（アプリ領域）は空になっていますので、ひな型となる階層ページング構造の後半部分をコピーします。」っていうけど、ひな型の階層ページング構造の後半部分も空じゃない→LoadELFでページング構造を作成し、現在のPML4テーブル（CR3レジスタの値）を設定している
・Loadapp()について、
else {
app_load. pml4 = pml4;
｝　この部分必要か？→コピーしてるのは階層ページング構造の値だけなので必要。確かにtmp_pml4とここのpml4の前半部分の指し示す先のオブジェクトは同じだけど、ページング構造自体が存在するアドレスは別（普通に別のオブジェクト）なのでtmp_pml4をそのまま使うことはできない。それやると同じアドレス参照することになってしまうので、ひな型が変更されてしまう
・SetupPML4って引数のtaskをどうしてるんだっけ→task.Context().cr3に作成したPML4テーブルの先頭アドレスを代入している
・std::bitset<kBitsPerMapLine>(alloc_map_[i]).count()の意味→
std::bitset<A>(B)はBという値をA桁のビット列に変換するという意味なのでMapLineTypeの配列であるalloc_map_の各要素（各ビットがフレームが使用中かどうかを表している）をビット列に変換して1であるビットの数を返している。
・ ExecuteFile内のCleanPageMapsの引数をプログラムヘッダの最初のLoadセグメントのアドレスから0xffff'8000'0000'0000に変更したのはどういうことなんだろう。最初のLoadセグメントのアドレスよりも小さい場所を指すLoadセグメントがプログラムヘッダのより後ろのほうにあった場合に対応したのかな

28章
・4バイト文字のときに上位5ビットまでマスクする理由→4バイト文字の先頭1バイトの有効ビットは下位3ビットだから。なお、2バイト文字は下位5ビット、3バイト文字は下位4ビットが有効
・ WriteUnicode（）のq[dx >> 3] & (0x80 >> (dx & 0x7))の意味→前提として1ビットが1ピクセルに対応している白黒の画像としてバイト配列の形でグリフが読み込まれている。まずdx >> 3をすることで実質的に8で割って、どのバイト配列中の要素が現在扱っているビットがあるものかを特定する。その後、dx & 0x7で下位3ビット、8で割った余り、すなわちバイト中のどの位置に現在扱っているビットを表すものがあるかを特定し、そのぶん右シフトして現在扱っているビットだけが1の8ビット列を作る。その後そのビット列と実際のグリフを比較することでそこが塗りつぶすべきビットかを判定している。
・bまで完了した時点で、画面描画以後何も実行されないエラー発生→実行時にnihongo.ttfがある場所を指定しないとInitializeFont()が失敗するので、それ以後にfreetypeのライブラリを使おうとすると壊れる
・*redir_char = 0;は*first_arg = 0;と同様に、Null文字を挿入することで文字列を分離している。引数が>以外にも存在する場合にこれをしないと>以降の文字も引数の一部とみなされてしまう。
・ExecuteLine（）にて、const auto [ u32, u8_next ] = ConvertUTF8To32(u8buf); Print(u32 ? u32 : U'□');を削除して PrintToFD(*files_[1], "%s", u8buf);にしてよい理由。Printは引数がutf32で符号化されている必要があるが、PrintToFDはその必要がない。PrintToFDはFileDescriptor::Writeを利用しており、ファイルの場合はfat::FileDescriptor::Writeが、ターミナルの場合はTerminalFileDescriptor::Write（引数二つのほうのTerminal:Printを使っている）が使われている。ファイルの場合はそもそもutf32で符号化した状態で書き込むべき理由がないので必要なく、普通にUTF8で書き込んでもらう。また、ターミナルに関しても最終的にConvertUTF8To32()をしてから出力されるのでここでコンバートする必要はない。utd32を扱う必要があるのはユーザーが閲覧するときだけなので、現状はターミナルに出力されるときにのみ扱えば良い。

29章
・memmoveはmemcpyと同じだが、コピー元とコピー先が重なる場合にmemcpyでは動作しない可能性がある
・・TaskManager::Finishについて、Wakeup()後はこのTaskに戻ってくることがないからRestoreContext()は呼び出されることがないのでは→Wakeup()はrunning_に追加するだけでコンテキストの切り替えは行わないのでRestoreContext（）は実行される
・TaskManager::Finishについて、tasks_などからは削除済みなのにCurrentTask()を呼び出せるのはなぜ→CurrentTask（）はrunning_の先頭要素を返す、すなわちRotateCurrentRunQueueによって設定された現在のタスクの次のものを返すので正常に動作する
・sortコマンドについて、これどこで入力待ってる？システムコールのReadEvent使ってないけど→fgetsがブロッキング関数で、入力を待機するのでこれでおｋ。終了するとNullを返すのでそれで初めてループを抜ける
・sortコマンドについて、コントロールDで入力終了するのってどっかで書いたっけ→？
・InitContextってなんだっけ。なんで第一引数にTaskTerminalが入ってるの→コンテキスト設定するやつ。第一引数はファンクションをとってそれのアドレスをRIPにいれる。第二引数はRSIにいれる（第一引数の関数の第二引数になる）
・catのパイプ処理の流れ→パイプ記号があると標準出力としてサブコマンドの入力を表すファイルディスクリプタが設定される。その後、catコマンド内でPrintToFDが呼ばれると標準出力のWriteが実行され、標準出力、すなわちサブコマンドの入力を表すディスクリプタに設定されたタスクにメッセージが送られる。サブコマンドの中でReadが実行されていたらそのメッセージを読み取ってなんかすることになる。
・sortコマンド後の入力について、sortコマンドはTerminalのInputKeyメソッドを経由しないのでバックスペースで削除したりとかはできない

30章
・FindCommand()でFindFileの戻り値のsecondが存在していたらnullptrを返す理由→secondはファイルに/が含まれているかどうかを表す真偽値なので。
・FindCommand()内のfile_entry.secondとstrchr(command, '/') != nullptrって同じ意味じゃない？
・CloseLayer()について、Activate(0)は、後半部分のActivate処理が行われないので単にアクティブ状態のものがあればそれをDeactivate（）するという処理になる。
・Windowクラスについて、なぜGetWindowRegionの実装を書いているのか。Activate()とかと同じように空の定義でよくないか→戻り値があるから当然なんか書かないといけない
・Winhelloとか実行中にターミナルの閉じるボタン押したら、仮にターミナルのほうがアクティブ状態だったとしても常にWinhelloのウィンドウのほうだけが消えるのは仕様か→仕様。ターミナルのほうがアクティブ状態だった場合は下記の流れになる。
・マウスクリック時に割り込み処理が発生し、SendCloseMessage()が呼び出される
・SendCloseMessage()でFindActiveLayerTask（）でactive_layer->GetActive()と layer_manager->FindLayer()、layer_task_map->find()を用いて現在アクティブなlayer及びtaskを取得する。ここで、現在アクティブなlayerとしてターミナルのlayerが取得できる。アプリはターミナルのタスク上で起動するものであり、ターミナルのlayerから取得できるtaskidはアプリのものと共通である。
・SendCloseMessage()でFindActiveLayerTask（）の戻り値のtaskidとlayerを用いて、taskidで特定されるTaskに対してそのlayerを閉じる旨のメッセージを送信する
・メッセージが送信されたことでタスクが再起動し、処理を行う。ここで、ReadEventを用いてアプリが待機しているのでそこから再起動が起こり、アプリ側の処理を行う。
・アプリの実行が終わり、ターミナルのタスクはTaskTerminalにて待機する。
なお、ターミナルがactiveではなく、アプリのウィンドウがアクティブだった場合でもlayer_task_mapを用いて取得されるタスクは同じなので流れに変化はない。（layer_task_mapにいつ追加したんだっけ→システムコールのOpenWindow中にlayer_task_mapに現在のタスクを追加する処理がある）
肝は、アプリがターミナルタスク上で動くということと、ReadEventを用いて待機を行うアプリの実行中はTaskTerminalのwhile文の中でSleepしていない（Switch文のcase kKeypush内のInputKey()の実行中である）ということ。
・usingって何だっけ→型定義
・tviewのCountUTF8Size何だっっけ→28章でやった何バイト文字かのやつ。
・tviewのCopyUTF8Stringのint spaces = tab - (x % tab)でなぜ(x % tab)を引いているのか→タブは行の先頭から数えてn文字境界にするものだから。
・tviewで"w:h:t"とタイプミスしたらウィンドウが開かなかった。エラー出力もなかった→:がないと引数をとらないオプションだとみなされ、optargがnullになるのでatoi(optarg)でエラー起きて落ちてる
